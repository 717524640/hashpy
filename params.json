{"name":"Hashpy","tagline":"Python wrapped fork of HASH first motion focal mechanism code.","body":"HASHpy\r\n------\r\n\r\nThis is a fork of HASH v1.2, the first motion focal mechanism program by Hardebeck and Shearer. The subroutines (in Fortran 77, which I did not write) are compiled into a python module, 'libhashpy.so', which will import all the subs and common blocks into the python namespace. There is a base class, HashPype, that contains attributes which hold data for a HASH calculation, and methods which can be called to do the HASH calculation. This class facilitates easily writing a 'hash driver' script in python. See below for details.\r\n\r\nNote: As stated in the in-code docs,  the current code is based on the 'hashdriver2' script, and as such, does not utilize the 'amp' routines for S/P amplitude measurements. This will most likely be added in the near future. If someone wants to take it upon themselves to add the compiler directives in the source and the methods to the HashPype class, throw me a pull request.\r\n\r\n### Installation\r\n\r\nThe latest version of this code uses `numpy.distutils`, which can nicely compile Fortran code. The source code and makefiles to remake the libhashpy module are installed to the hashpy folder, so with a little hacking, one could just remake them in place, if one wanted to change the source code.\r\n\r\nFor basic install:\r\n\r\n```shell\r\n# First, install dependencies. Then cd to this top directory and:\r\npython setup.py install\r\n\r\n# or use pip\r\npip install git+https://github.com/markcwill/hashpy.git\r\n\r\n```\r\n\r\n### Testing and Usage\r\n\r\nFor lower-level programming, the Fortran subroutines are available in `hashpy.libhashpy`\r\n\r\n```python\r\nIn [1]: from hashpy import libhashpy\r\n\r\nIn [2]: libhashpy?\r\nType:       module\r\nBase Class: <type 'module'>\r\nString Form:<module 'hashpy.libhashpy' from '/opt/antelope/python2.7.2-64/lib/python2.7/site-packages/hashpy/libhashpy.so'>\r\nNamespace:  Interactive\r\nFile:       /opt/antelope/python2.7.2-64/lib/python2.7/site-packages/hashpy/libhashpy.so\r\nDocstring:\r\nThis module 'libhashpy' is auto-generated with f2py (version:1).\r\nFunctions:\r\n  nf,strike,dip,rake,faults,slips = focalmc(p_azi_mc,p_the_mc,p_pol,p_qual,nmc,dang,maxout,nextra,ntotal,npsta=len(p_pol))\r\n  nsltn,str_avg,dip_avg,rak_avg,prob,rms_diff = mech_prob(norm1in,norm2in,cangle,prob_max,nf=shape(norm1in,1))\r\n  norm1_avg,norm2_avg = mech_avg(norm1,norm2,nf=shape(norm1,1))\r\n  rota = mech_rot(norm1,norm2,slip1,slip2)\r\n  v3 = cross(v1,v2)\r\n  to_car(the,phi,r,x,y,z)\r\n  fpcoor(strike,dip,rake,fnorm,slip,idir)\r\n  fran = ran_norm()\r\n  mfrac,stdr = get_misf(p_azi_mc,p_the_mc,p_pol,p_qual,str_avg,dip_avg,rak_avg,npol=len(p_azi_mc))\r\n  magap,mpgap = get_gap(p_azi_mc,p_the_mc,npol=len(p_azi_mc))\r\n  sort(ra,n=len(ra))\r\n  ntab = mk_table(ntab)\r\n  tt,iflag = get_tts(ip,del,qdep)\r\n  layertrace(p1,h1,utop1,ubot1,imth,dx1,dt1,irtr)\r\n  flat,flon,felev = getstat_tri(stlfile,snam,scom,snet)\r\n  stpol = check_pol(polfile,snam,evyr,evmon,evdy,evhr)\r\n  qcor = get_cor(stlfile,snam,scom,snet)\r\n  ntab = mk_table_add(ind,vmodel)\r\nCOMMON blocks:\r\n  /angtable/ table(101,14,10),delttab(101),deptab(14),ndel,ndep\r\n.\r\n\r\nIn [3]: \r\n```\r\n\r\n### Input/Output\r\n\r\nData can be input into HASH in various formats. This is currently handled in HASHpy by registering a format in the `hashpy.io` module by adding a module/functions to the dictionary in `hashpy.io.core`. (May change in future releases). I/O functions are then called by the HashPype methods `HashPype.input()` and `HashPype.output()`. If the 'output' method is called with no format it will return a simple string with the event ID with the best strike/dip/rake\r\n\r\nCurrently Supports:\r\n* ObsPy Event object I/O\r\n* Antelope Datascope database I/O\r\n\r\n```python\r\n# Usage example:\r\n# Typical \"hash_driver2\" style script\r\n# Using the ObsPy Event format as input for origin, picks, and arrivals\r\n\r\nfrom hashpy import HashPype, HashError\r\n\r\n# Make an ObsPy Event, or get from a QuakeML file\r\nfrom obspy.core.event import readEvents\r\nevent = readEvents('my_quakeml_file.xml').events[0]\r\n\r\n# Set configuration at creation with a dict...\r\n# ...can from file or interactively, etc\r\nconfig = { \"npolmin\" : 10,\r\n           \"max_agap\": 90,\r\n           \"vmodels\" : ['/path/to/my/vmodel/file1.vz', \r\n                        '/new/picking/model/file2.vz',\r\n                       ] \r\n           }\r\n\r\nhp = HashPype(**config)\r\nhp.input(event, format=\"OBSPY\")\r\nhp.load_velocity_models()\r\nhp.generate_trial_data()\r\nhp.calculate_takeoff_angles()\r\n\r\npass1 = hp.check_minimum_polarity()\r\npass2 = hp.check_maximum_gap()\r\n\r\nif pass1 and pass2:\r\n    hp.calculate_hash_focalmech()\r\n    hp.calculate_quality()\r\n    print hp.output() # default output is a simple string\r\nelse:\r\n    raise HashError(\"Didn't pass user checks!\")\r\n\r\n```\r\n\r\n### Plotting\r\n\r\nA trial implementation of plotting exists, using `matplotlib` and the `mplstereonet` package, as the  `hashpy.plotting.focalmechplotter.FocalMechPlotter` class. It accepts an ObsPy Event containing Picks, Origin/Arrivals, FocalMechanism, etc, objects (as output from HashPype) and generates a stereonet plot. Multiple FocalMechansim solutions from HASH are accessible through the navigation toolbar 'back' and 'forward' arrows.\r\n\r\n```python\r\n# Get an obspy Event object as output\r\n>>> event = hp.output(format=\"OBSPY\")\r\n# Pass to plotter class as constructor variable\r\n>>> fmp = FocalMechPlotter(event)\r\n# Plots a figure, accessible as 'fmp.fig'\r\n```\r\n\r\n\r\n\r\n### Dependencies\r\n\r\n#### Required\r\n* Fortran compiler + library (tested with gfortran + libgfortran3)\r\n* NumPy (main dependancy, for numerical arrays and f2py compiling)\r\n\r\n#### Optional\r\n* [ObsPy](https://github.com/obspy/obspy.git) (Only for plotting and ObsPy I/O))\r\n* [mplstereonet](https://github.com/joferkington/mplstereonet.git) (Only for plotting)\r\n* [Antelope](http://www.brtt.com) (Only for Antelope database I/O)\r\n\r\n### HASH references\r\n\r\n* Hardebeck, Jeanne L. and Peter M. Shearer, A new method for determining first-\r\n  motion focal mechanisms, Bulletin of the Seismological Society of America, 92,\r\n  2264-2276, 2002.\r\n* Hardebeck, Jeanne L. and Peter M. Shearer, Using S/P Amplitude Ratios to\r\n  Constrain the Focal Mechanisms of Small Earthquakes, Bulletin of the\r\n  Seismological Society of America, 93, 2434-2444, 2003.\r\n\r\n### Future\r\nAdd remaining HASH routines (like those in fmamp_subs.f) to wrapped library and class methods.\r\n\r\nIf I ever get ambitious, I would redo the structure of some of the Fortran subroutines (already started this with vel-subs2) and rewrite them in Fortran 90/95/2003. Probably couldn't ditch the common blocks without a full rewrite, but at least try and get rid of the GOTOs. Biggest improvement would be allocatable arrays, so you could avoid the includes and max-size arrays.\r\n\r\nThere will probably be small adjustments to the locations and structure of what functions are in what files, but the HashPype class and methods will be the main way to interact with HASH.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}